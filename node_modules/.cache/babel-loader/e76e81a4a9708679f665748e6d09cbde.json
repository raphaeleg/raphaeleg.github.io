{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectMethods = exports.LooksAhead = void 0;\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar has_1 = __importDefault(require(\"lodash/has\"));\n\nvar parser_1 = require(\"../parser\");\n\nvar keys_1 = require(\"../../grammar/keys\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nvar llk_lookahead_1 = require(\"../../grammar/llk_lookahead\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\n\n\nvar LooksAhead =\n/** @class */\nfunction () {\n  function LooksAhead() {}\n\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\") ? config.maxLookahead // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookaheadStrategy = (0, has_1.default)(config, \"lookaheadStrategy\") ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n    : new llk_lookahead_1.LLkLookaheadStrategy({\n      maxLookahead: this.maxLookahead\n    });\n    this.lookAheadFuncsCache = new Map();\n  };\n\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n\n    (0, forEach_1.default)(rules, function (currRule) {\n      _this.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n        var _a = collectMethods(currRule),\n            alternation = _a.alternation,\n            repetition = _a.repetition,\n            option = _a.option,\n            repetitionMandatory = _a.repetitionMandatory,\n            repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n            repetitionWithSeparator = _a.repetitionWithSeparator;\n\n        (0, forEach_1.default)(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n\n          _this.TRACE_INIT(\"\".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function () {\n            var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || _this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: _this.dynamicTokensEnabled\n            });\n\n            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        (0, forEach_1.default)(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, \"Repetition\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, \"Option\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n      });\n    });\n  };\n\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n\n    this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({\n        prodOccurrence: prodOccurrence,\n        rule: rule,\n        maxLookahead: prodMaxLookahead || _this.maxLookahead,\n        dynamicTokensEnabled: _this.dynamicTokensEnabled,\n        prodType: prodType\n      });\n\n      var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n\n      _this.setLaFuncCache(key, laFunc);\n    });\n  }; // this actually returns a number, but it is always used as a string (object prop key)\n\n\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n  };\n\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next */\n\n\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n\n  return LooksAhead;\n}();\n\nexports.LooksAhead = LooksAhead;\n\nvar DslMethodsCollectorVisitor =\n/** @class */\nfunction (_super) {\n  __extends(DslMethodsCollectorVisitor, _super);\n\n  function DslMethodsCollectorVisitor() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n    return _this;\n  }\n\n  DslMethodsCollectorVisitor.prototype.reset = function () {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n    this.dslMethods.option.push(option);\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n    this.dslMethods.repetition.push(many);\n  };\n\n  DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n    this.dslMethods.alternation.push(or);\n  };\n\n  return DslMethodsCollectorVisitor;\n}(gast_1.GAstVisitor);\n\nvar collectorVisitor = new DslMethodsCollectorVisitor();\n\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  var dslMethods = collectorVisitor.dslMethods; // avoid uncleaned references\n\n  collectorVisitor.reset();\n  return dslMethods;\n}\n\nexports.collectMethods = collectMethods;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAMA;;AAUA;;AAUA;;AACA;AAEA;;;;;AAGA;AAAA;AAAA;EAAA,uBAmKC;;EA7JCA,gDAAeC,MAAf,EAAoC;IAClC,KAAKC,oBAAL,GAA4B,mBAAID,MAAJ,EAAY,sBAAZ,IACvBA,MAAM,CAACC,oBADgB,CACiB;IADjB,EAExBC,+BAAsBD,oBAF1B;IAIA,KAAKE,YAAL,GAAoB,mBAAIH,MAAJ,EAAY,cAAZ,IACfA,MAAM,CAACG,YADQ,CACgB;IADhB,EAEhBD,+BAAsBC,YAF1B;IAIA,KAAKC,iBAAL,GAAyB,mBAAIJ,MAAJ,EAAY,mBAAZ,IACpBA,MAAM,CAACI,iBADa,CAC4B;IAD5B,EAErB,IAAIC,oCAAJ,CAAyB;MAAEF,YAAY,EAAE,KAAKA;IAArB,CAAzB,CAFJ;IAIA,KAAKG,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B;EACD,CAdD;;EAgBAR,8DAAkDS,KAAlD,EAA+D;IAA/D;;IACE,uBAAQA,KAAR,EAAe,UAACC,QAAD,EAAS;MACtBC,KAAI,CAACC,UAAL,CAAgB,UAAGF,QAAQ,CAACG,IAAZ,EAAgB,iBAAhB,CAAhB,EAAmD;QAC3C,SAOFC,cAAc,CAACJ,QAAD,CAPZ;QAAA,IACJK,WAAW,iBADP;QAAA,IAEJC,UAAU,gBAFN;QAAA,IAGJC,MAAM,YAHF;QAAA,IAIJC,mBAAmB,yBAJf;QAAA,IAKJC,gCAAgC,sCAL5B;QAAA,IAMJC,uBAAuB,6BANnB;;QASN,uBAAQL,WAAR,EAAqB,UAACM,QAAD,EAAS;UAC5B,IAAMC,OAAO,GAAGD,QAAQ,CAACE,GAAT,KAAiB,CAAjB,GAAqB,EAArB,GAA0BF,QAAQ,CAACE,GAAnD;;UACAZ,KAAI,CAACC,UAAL,CAAgB,UAAG,iCAAqBS,QAArB,CAAH,EAAiCG,MAAjC,CAAoCF,OAApC,CAAhB,EAA+D;YAC7D,IAAMG,MAAM,GAAGd,KAAI,CAACN,iBAAL,CAAuBqB,4BAAvB,CAAoD;cACjEC,cAAc,EAAEN,QAAQ,CAACE,GADwC;cAEjEK,IAAI,EAAElB,QAF2D;cAGjEN,YAAY,EAAEiB,QAAQ,CAACjB,YAAT,IAAyBO,KAAI,CAACP,YAHqB;cAIjEyB,aAAa,EAAER,QAAQ,CAACQ,aAJyC;cAKjE3B,oBAAoB,EAAES,KAAI,CAACT;YALsC,CAApD,CAAf;;YAQA,IAAM4B,GAAG,GAAG,wCACVnB,KAAI,CAACoB,mBAAL,CAAyBrB,QAAQ,CAACG,IAAlC,CADU,EAEVmB,aAFU,EAGVX,QAAQ,CAACE,GAHC,CAAZ;;YAKAZ,KAAI,CAACsB,cAAL,CAAoBH,GAApB,EAAyBL,MAAzB;UACD,CAfD;QAgBD,CAlBD;QAoBA,uBAAQT,UAAR,EAAoB,UAACK,QAAD,EAAS;UAC3BV,KAAI,CAACuB,oBAAL,CACExB,QADF,EAEEW,QAAQ,CAACE,GAFX,EAGES,eAHF,EAIE,YAJF,EAKEX,QAAQ,CAACjB,YALX,EAME,iCAAqBiB,QAArB,CANF;QAQD,CATD;QAWA,uBAAQJ,MAAR,EAAgB,UAACI,QAAD,EAAS;UACvBV,KAAI,CAACuB,oBAAL,CACExB,QADF,EAEEW,QAAQ,CAACE,GAFX,EAGES,iBAHF,EAIE,QAJF,EAKEX,QAAQ,CAACjB,YALX,EAME,iCAAqBiB,QAArB,CANF;QAQD,CATD;QAWA,uBAAQH,mBAAR,EAA6B,UAACG,QAAD,EAAS;UACpCV,KAAI,CAACuB,oBAAL,CACExB,QADF,EAEEW,QAAQ,CAACE,GAFX,EAGES,uBAHF,EAIE,qBAJF,EAKEX,QAAQ,CAACjB,YALX,EAME,iCAAqBiB,QAArB,CANF;QAQD,CATD;QAWA,uBAAQF,gCAAR,EAA0C,UAACE,QAAD,EAAS;UACjDV,KAAI,CAACuB,oBAAL,CACExB,QADF,EAEEW,QAAQ,CAACE,GAFX,EAGES,2BAHF,EAIE,kCAJF,EAKEX,QAAQ,CAACjB,YALX,EAME,iCAAqBiB,QAArB,CANF;QAQD,CATD;QAWA,uBAAQD,uBAAR,EAAiC,UAACC,QAAD,EAAS;UACxCV,KAAI,CAACuB,oBAAL,CACExB,QADF,EAEEW,QAAQ,CAACE,GAFX,EAGES,mBAHF,EAIE,yBAJF,EAKEX,QAAQ,CAACjB,YALX,EAME,iCAAqBiB,QAArB,CANF;QAQD,CATD;MAUD,CApFD;IAqFD,CAtFD;EAuFD,CAxFD;;EA0FArB,sDAEE4B,IAFF,EAGED,cAHF,EAIEQ,OAJF,EAKEC,QALF,EAMEC,gBANF,EAOEC,aAPF,EAOuB;IAPvB;;IASE,KAAK1B,UAAL,CACE,UAAG0B,aAAH,EAAgBd,MAAhB,CAAmBG,cAAc,KAAK,CAAnB,GAAuB,EAAvB,GAA4BA,cAA/C,CADF,EAEE;MACE,IAAMF,MAAM,GAAGd,KAAI,CAACN,iBAAL,CAAuBkC,yBAAvB,CAAiD;QAC9DZ,cAAc,gBADgD;QAE9DC,IAAI,MAF0D;QAG9DxB,YAAY,EAAEiC,gBAAgB,IAAI1B,KAAI,CAACP,YAHuB;QAI9DF,oBAAoB,EAAES,KAAI,CAACT,oBAJmC;QAK9DkC,QAAQ;MALsD,CAAjD,CAAf;;MAOA,IAAMN,GAAG,GAAG,wCACVnB,KAAI,CAACoB,mBAAL,CAAyBH,IAAI,CAACf,IAA9B,CADU,EAEVsB,OAFU,EAGVR,cAHU,CAAZ;;MAKAhB,KAAI,CAACsB,cAAL,CAAoBH,GAApB,EAAyBL,MAAzB;IACD,CAhBH;EAkBD,CA3BD,CAhHF,CA6IE;;;EACAzB,6DAEEwC,YAFF,EAGEC,UAHF,EAGoB;IAElB,IAAMC,iBAAiB,GAAQ,KAAKC,4BAAL,EAA/B;IACA,OAAO,wCACLD,iBADK,EAELF,YAFK,EAGLC,UAHK,CAAP;EAKD,CAXD;;EAaAzC,oDAAwC8B,GAAxC,EAAmD;IACjD,OAAO,KAAKvB,mBAAL,CAAyBqC,GAAzB,CAA6Bd,GAA7B,CAAP;EACD,CAFD;EAIA;;;EACA9B,gDAAoC8B,GAApC,EAAiDe,KAAjD,EAAgE;IAC9D,KAAKtC,mBAAL,CAAyBuC,GAAzB,CAA6BhB,GAA7B,EAAkCe,KAAlC;EACD,CAFD;;EAGF;AAAC,CAnKD;;AAAaE;;AAqKb;AAAA;AAAA;EAAyCC;;EAAzC;IAAA;;IACSrC,mBAOH;MACFM,MAAM,EAAE,EADN;MAEFF,WAAW,EAAE,EAFX;MAGFC,UAAU,EAAE,EAHV;MAIFI,uBAAuB,EAAE,EAJvB;MAKFF,mBAAmB,EAAE,EALnB;MAMFC,gCAAgC,EAAE;IANhC,CAPG;;EAoDR;;EApCC8B;IACE,KAAKC,UAAL,GAAkB;MAChBjC,MAAM,EAAE,EADQ;MAEhBF,WAAW,EAAE,EAFG;MAGhBC,UAAU,EAAE,EAHI;MAIhBI,uBAAuB,EAAE,EAJT;MAKhBF,mBAAmB,EAAE,EALL;MAMhBC,gCAAgC,EAAE;IANlB,CAAlB;EAQD,CATD;;EAWO8B,mDAAP,UAAmBhC,MAAnB,EAAiC;IAC/B,KAAKiC,UAAL,CAAgBjC,MAAhB,CAAuBkC,IAAvB,CAA4BlC,MAA5B;EACD,CAFM;;EAIAgC,oEAAP,UAAoCG,OAApC,EAAoE;IAClE,KAAKF,UAAL,CAAgB9B,uBAAhB,CAAwC+B,IAAxC,CAA6CC,OAA7C;EACD,CAFM;;EAIAH,gEAAP,UAAgCI,UAAhC,EAA+D;IAC7D,KAAKH,UAAL,CAAgBhC,mBAAhB,CAAoCiC,IAApC,CAAyCE,UAAzC;EACD,CAFM;;EAIAJ,6EAAP,UACEK,aADF,EACiD;IAE/C,KAAKJ,UAAL,CAAgB/B,gCAAhB,CAAiDgC,IAAjD,CAAsDG,aAAtD;EACD,CAJM;;EAMAL,uDAAP,UAAuBM,IAAvB,EAAuC;IACrC,KAAKL,UAAL,CAAgBlC,UAAhB,CAA2BmC,IAA3B,CAAgCI,IAAhC;EACD,CAFM;;EAIAN,wDAAP,UAAwBO,EAAxB,EAAuC;IACrC,KAAKN,UAAL,CAAgBnC,WAAhB,CAA4BoC,IAA5B,CAAiCK,EAAjC;EACD,CAFM;;EAGT;AAAC,CArDD,CAAyCC,kBAAzC;;AAuDA,IAAMC,gBAAgB,GAAG,IAAIT,0BAAJ,EAAzB;;AACA,SAAgBnC,cAAhB,CAA+Bc,IAA/B,EAAyC;EAQvC8B,gBAAgB,CAACC,KAAjB;EACA/B,IAAI,CAACgC,MAAL,CAAYF,gBAAZ;EACA,IAAMR,UAAU,GAAGQ,gBAAgB,CAACR,UAApC,CAVuC,CAWvC;;EACAQ,gBAAgB,CAACC,KAAjB;EACA,OAAYT,UAAZ;AACD;;AAdDH","names":["LooksAhead","config","dynamicTokensEnabled","parser_1","maxLookahead","lookaheadStrategy","llk_lookahead_1","lookAheadFuncsCache","Map","rules","currRule","_this","TRACE_INIT","name","collectMethods","alternation","repetition","option","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","currProd","prodIdx","idx","concat","laFunc","buildLookaheadForAlternation","prodOccurrence","rule","hasPredicates","key","fullRuleNameToShort","keys_1","setLaFuncCache","computeLookaheadFunc","prodKey","prodType","prodMaxLookahead","dslMethodName","buildLookaheadForOptional","dslMethodIdx","occurrence","currRuleShortName","getLastExplicitRuleShortName","get","value","set","exports","__extends","DslMethodsCollectorVisitor","dslMethods","push","manySep","atLeastOne","atLeastOneSep","many","or","gast_1","collectorVisitor","reset","accept"],"sources":["/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts"],"sourcesContent":["import forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n  lookaheadStrategy: ILookaheadStrategy\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n\n    this.lookAheadFuncsCache = new Map()\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            })\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType\n        })\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[]\n    alternation: Alternation[]\n    repetition: Repetition[]\n    repetitionWithSeparator: RepetitionWithSeparator[]\n    repetitionMandatory: RepetitionMandatory[]\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(rule: Rule): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n"]},"metadata":{},"sourceType":"script"}