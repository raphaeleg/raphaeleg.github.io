{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = exports.validateLookahead = void 0;\n\nvar first_1 = __importDefault(require(\"lodash/first\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\n\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\n\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\n\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nvar values_1 = __importDefault(require(\"lodash/values\"));\n\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\n\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nvar gast_3 = require(\"@chevrotain/gast\");\n\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\n\nvar tokens_1 = require(\"../../scan/tokens\");\n\nfunction validateLookahead(options) {\n  var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return (0, map_1.default)(lookaheadValidationErrorMessages, function (errorMessage) {\n    return __assign({\n      type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n    }, errorMessage);\n  });\n}\n\nexports.validateLookahead = validateLookahead;\n\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(gast_3.GAstVisitor);\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nvar RepetitionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionCollector, _super);\n\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\n\nexports.RepetitionCollector = RepetitionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateLookahead","options","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","tokenTypes","grammarName","errorMessage","type","parser_1","CUSTOM_LOOKAHEAD_VALIDATION","exports","validateGrammar","topLevels","errMsgProvider","duplicateErrors","currTopLevel","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_2","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_3","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","tokens_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","globalMaxLookahead","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType,\n  Rule\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  })\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage\n  }))\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n"]},"metadata":{},"sourceType":"script"}