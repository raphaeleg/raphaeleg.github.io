{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom/client';\nimport { Vector3, DoubleSide, OrthographicCamera, PerspectiveCamera } from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nconst v1 = new Vector3();\nconst v2 = new Vector3();\nconst v3 = new Vector3();\n\nfunction defaultCalculatePosition(el, camera, size) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  objectPos.project(camera);\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];\n}\n\nfunction isObjectBehindCamera(el, camera) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n  const deltaCamObj = objectPos.sub(cameraPos);\n  const camDir = camera.getWorldDirection(v3);\n  return deltaCamObj.angleTo(camDir) > Math.PI / 2;\n}\n\nfunction isObjectVisible(el, camera, raycaster, occlude) {\n  const elPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const screenPos = elPos.clone();\n  screenPos.project(camera);\n  raycaster.setFromCamera(screenPos, camera);\n  const intersects = raycaster.intersectObjects(occlude, true);\n\n  if (intersects.length) {\n    const intersectionDistance = intersects[0].distance;\n    const pointDistance = elPos.distanceTo(raycaster.ray.origin);\n    return pointDistance < intersectionDistance;\n  }\n\n  return true;\n}\n\nfunction objectScale(el, camera) {\n  if (camera instanceof OrthographicCamera) {\n    return camera.zoom;\n  } else if (camera instanceof PerspectiveCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const vFOV = camera.fov * Math.PI / 180;\n    const dist = objectPos.distanceTo(cameraPos);\n    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;\n    return 1 / scaleFOV;\n  } else {\n    return 1;\n  }\n}\n\nfunction objectZIndex(el, camera, zIndexRange) {\n  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const dist = objectPos.distanceTo(cameraPos);\n    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);\n    const B = zIndexRange[1] - A * camera.far;\n    return Math.round(A * dist + B);\n  }\n\n  return undefined;\n}\n\nconst epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;\n\nfunction getCSSMatrix(matrix, multipliers) {\n  let prepend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let matrix3d = 'matrix3d(';\n\n  for (let i = 0; i !== 16; i++) {\n    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');\n  }\n\n  return prepend + matrix3d;\n}\n\nconst getCameraCSSMatrix = (multipliers => {\n  return matrix => getCSSMatrix(matrix, multipliers);\n})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);\n\nconst getObjectCSSMatrix = (scaleMultipliers => {\n  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');\n})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);\n\nfunction isRefObject(ref) {\n  return ref && typeof ref === 'object' && 'current' in ref;\n}\n\nconst Html = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    children,\n    eps = 0.001,\n    style,\n    className,\n    prepend,\n    center,\n    fullscreen,\n    portal,\n    distanceFactor,\n    sprite = false,\n    transform = false,\n    occlude,\n    onOcclude,\n    castShadow,\n    receiveShadow,\n    material,\n    geometry,\n    zIndexRange = [16777271, 0],\n    calculatePosition = defaultCalculatePosition,\n    as = 'div',\n    wrapperClass,\n    pointerEvents = 'auto',\n    ...props\n  } = _ref;\n  const {\n    gl,\n    camera,\n    scene,\n    size,\n    raycaster,\n    events,\n    viewport\n  } = useThree();\n  const [el] = React.useState(() => document.createElement(as));\n  const root = React.useRef();\n  const group = React.useRef(null);\n  const oldZoom = React.useRef(0);\n  const oldPosition = React.useRef([0, 0]);\n  const transformOuterRef = React.useRef(null);\n  const transformInnerRef = React.useRef(null); // Append to the connected element, which makes HTML work with views\n\n  const target = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;\n  const occlusionMeshRef = React.useRef(null);\n  const isMeshSizeSet = React.useRef(false);\n  const isRayCastOcclusion = React.useMemo(() => {\n    return occlude && occlude !== 'blending' || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    const el = gl.domElement;\n\n    if (occlude && occlude === 'blending') {\n      el.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;\n      el.style.position = 'absolute';\n      el.style.pointerEvents = 'none';\n    } else {\n      el.style.zIndex = null;\n      el.style.position = null;\n      el.style.pointerEvents = null;\n    }\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    if (group.current) {\n      const currentRoot = root.current = ReactDOM.createRoot(el);\n      scene.updateMatrixWorld();\n\n      if (transform) {\n        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;\n      } else {\n        const vec = calculatePosition(group.current, camera, size);\n        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;\n      }\n\n      if (target) {\n        if (prepend) target.prepend(el);else target.appendChild(el);\n      }\n\n      return () => {\n        if (target) target.removeChild(el);\n        currentRoot.unmount();\n      };\n    }\n  }, [target, transform]);\n  React.useLayoutEffect(() => {\n    if (wrapperClass) el.className = wrapperClass;\n  }, [wrapperClass]);\n  const styles = React.useMemo(() => {\n    if (transform) {\n      return {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: size.width,\n        height: size.height,\n        transformStyle: 'preserve-3d',\n        pointerEvents: 'none'\n      };\n    } else {\n      return {\n        position: 'absolute',\n        transform: center ? 'translate3d(-50%,-50%,0)' : 'none',\n        ...(fullscreen && {\n          top: -size.height / 2,\n          left: -size.width / 2,\n          width: size.width,\n          height: size.height\n        }),\n        ...style\n      };\n    }\n  }, [style, center, fullscreen, size, transform]);\n  const transformInnerStyles = React.useMemo(() => ({\n    position: 'absolute',\n    pointerEvents\n  }), [pointerEvents]);\n  React.useLayoutEffect(() => {\n    isMeshSizeSet.current = false;\n\n    if (transform) {\n      var _root$current;\n\n      (_root$current = root.current) == null ? void 0 : _root$current.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformOuterRef,\n        style: styles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformInnerRef,\n        style: transformInnerStyles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        className: className,\n        style: style,\n        children: children\n      }))));\n    } else {\n      var _root$current2;\n\n      (_root$current2 = root.current) == null ? void 0 : _root$current2.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        style: styles,\n        className: className,\n        children: children\n      }));\n    }\n  });\n  const visible = React.useRef(true);\n  useFrame(gl => {\n    if (group.current) {\n      camera.updateMatrixWorld();\n      group.current.updateWorldMatrix(true, false);\n      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);\n\n      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {\n        const isBehindCamera = isObjectBehindCamera(group.current, camera);\n        let raytraceTarget = false;\n\n        if (isRayCastOcclusion) {\n          if (occlude !== 'blending') {\n            raytraceTarget = [scene];\n          } else if (Array.isArray(occlude)) {\n            raytraceTarget = occlude.map(item => item.current);\n          }\n        }\n\n        const previouslyVisible = visible.current;\n\n        if (raytraceTarget) {\n          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);\n          visible.current = isvisible && !isBehindCamera;\n        } else {\n          visible.current = !isBehindCamera;\n        }\n\n        if (previouslyVisible !== visible.current) {\n          if (onOcclude) onOcclude(!visible.current);else el.style.display = visible.current ? 'block' : 'none';\n        }\n\n        const halfRange = Math.floor(zIndexRange[0] / 2);\n        const zRange = occlude ? isRayCastOcclusion //\n        ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;\n        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;\n\n        if (transform) {\n          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];\n          const fov = camera.projectionMatrix.elements[5] * heightHalf;\n          const {\n            isOrthographicCamera,\n            top,\n            left,\n            bottom,\n            right\n          } = camera;\n          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);\n          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;\n          let matrix = group.current.matrixWorld;\n\n          if (sprite) {\n            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);\n            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n          }\n\n          el.style.width = size.width + 'px';\n          el.style.height = size.height + 'px';\n          el.style.perspective = isOrthographicCamera ? '' : `${fov}px`;\n\n          if (transformOuterRef.current && transformInnerRef.current) {\n            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;\n            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));\n          }\n        } else {\n          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;\n          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;\n        }\n\n        oldPosition.current = vec;\n        oldZoom.current = camera.zoom;\n      }\n    }\n\n    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {\n      if (transform) {\n        if (transformOuterRef.current) {\n          const el = transformOuterRef.current.children[0];\n\n          if (el != null && el.clientWidth && el != null && el.clientHeight) {\n            const {\n              isOrthographicCamera\n            } = camera;\n\n            if (isOrthographicCamera || geometry) {\n              if (props.scale) {\n                if (!Array.isArray(props.scale)) {\n                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);\n                } else if (props.scale instanceof Vector3) {\n                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));\n                } else {\n                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);\n                }\n              }\n            } else {\n              const ratio = (distanceFactor || 10) / 400;\n              const w = el.clientWidth * ratio;\n              const h = el.clientHeight * ratio;\n              occlusionMeshRef.current.scale.set(w, h, 1);\n            }\n\n            isMeshSizeSet.current = true;\n          }\n        }\n      } else {\n        const ele = el.children[0];\n\n        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {\n          const ratio = 1 / viewport.factor;\n          const w = ele.clientWidth * ratio;\n          const h = ele.clientHeight * ratio;\n          occlusionMeshRef.current.scale.set(w, h, 1);\n          isMeshSizeSet.current = true;\n        }\n\n        occlusionMeshRef.current.lookAt(gl.camera.position);\n      }\n    }\n  });\n  const shaders = React.useMemo(() => ({\n    vertexShader: !transform ?\n    /* glsl */\n    `\n          /*\n            This shader is from the THREE's SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if \"transfrom\" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ` : undefined,\n    fragmentShader:\n    /* glsl */\n    `\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `\n  }), [transform]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: group\n  }), occlude && !isRayCastOcclusion && /*#__PURE__*/React.createElement(\"mesh\", {\n    castShadow: castShadow,\n    receiveShadow: receiveShadow,\n    ref: occlusionMeshRef\n  }, geometry || /*#__PURE__*/React.createElement(\"planeGeometry\", null), material || /*#__PURE__*/React.createElement(\"shaderMaterial\", {\n    side: DoubleSide,\n    vertexShader: shaders.vertexShader,\n    fragmentShader: shaders.fragmentShader\n  })));\n});\nexport { Html };","map":{"version":3,"names":["_extends","React","ReactDOM","Vector3","DoubleSide","OrthographicCamera","PerspectiveCamera","useThree","useFrame","v1","v2","v3","defaultCalculatePosition","el","camera","size","objectPos","setFromMatrixPosition","matrixWorld","project","widthHalf","width","heightHalf","height","x","y","isObjectBehindCamera","cameraPos","deltaCamObj","sub","camDir","getWorldDirection","angleTo","Math","PI","isObjectVisible","raycaster","occlude","elPos","screenPos","clone","setFromCamera","intersects","intersectObjects","length","intersectionDistance","distance","pointDistance","distanceTo","ray","origin","objectScale","zoom","vFOV","fov","dist","scaleFOV","tan","objectZIndex","zIndexRange","A","far","near","B","round","undefined","epsilon","value","abs","getCSSMatrix","matrix","multipliers","prepend","matrix3d","i","elements","getCameraCSSMatrix","getObjectCSSMatrix","scaleMultipliers","factor","f","isRefObject","ref","Html","forwardRef","children","eps","style","className","center","fullscreen","portal","distanceFactor","sprite","transform","onOcclude","castShadow","receiveShadow","material","geometry","calculatePosition","as","wrapperClass","pointerEvents","props","gl","scene","events","viewport","useState","document","createElement","root","useRef","group","oldZoom","oldPosition","transformOuterRef","transformInnerRef","target","current","connected","domElement","parentNode","occlusionMeshRef","isMeshSizeSet","isRayCastOcclusion","useMemo","Array","isArray","useLayoutEffect","zIndex","floor","position","currentRoot","createRoot","updateMatrixWorld","cssText","vec","appendChild","removeChild","unmount","styles","top","left","transformStyle","transformInnerStyles","_root$current","render","_root$current2","visible","updateWorldMatrix","isBehindCamera","raytraceTarget","map","item","previouslyVisible","isvisible","display","halfRange","zRange","projectionMatrix","isOrthographicCamera","bottom","right","cameraMatrix","matrixWorldInverse","cameraTransform","transpose","copyPosition","scale","perspective","clientWidth","clientHeight","setScalar","copy","divideScalar","set","ratio","w","h","ele","lookAt","shaders","vertexShader","fragmentShader","side"],"sources":["/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@react-three/drei/web/Html.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom/client';\nimport { Vector3, DoubleSide, OrthographicCamera, PerspectiveCamera } from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nconst v1 = new Vector3();\nconst v2 = new Vector3();\nconst v3 = new Vector3();\n\nfunction defaultCalculatePosition(el, camera, size) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  objectPos.project(camera);\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];\n}\n\nfunction isObjectBehindCamera(el, camera) {\n  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n  const deltaCamObj = objectPos.sub(cameraPos);\n  const camDir = camera.getWorldDirection(v3);\n  return deltaCamObj.angleTo(camDir) > Math.PI / 2;\n}\n\nfunction isObjectVisible(el, camera, raycaster, occlude) {\n  const elPos = v1.setFromMatrixPosition(el.matrixWorld);\n  const screenPos = elPos.clone();\n  screenPos.project(camera);\n  raycaster.setFromCamera(screenPos, camera);\n  const intersects = raycaster.intersectObjects(occlude, true);\n\n  if (intersects.length) {\n    const intersectionDistance = intersects[0].distance;\n    const pointDistance = elPos.distanceTo(raycaster.ray.origin);\n    return pointDistance < intersectionDistance;\n  }\n\n  return true;\n}\n\nfunction objectScale(el, camera) {\n  if (camera instanceof OrthographicCamera) {\n    return camera.zoom;\n  } else if (camera instanceof PerspectiveCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const vFOV = camera.fov * Math.PI / 180;\n    const dist = objectPos.distanceTo(cameraPos);\n    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;\n    return 1 / scaleFOV;\n  } else {\n    return 1;\n  }\n}\n\nfunction objectZIndex(el, camera, zIndexRange) {\n  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {\n    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);\n    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);\n    const dist = objectPos.distanceTo(cameraPos);\n    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);\n    const B = zIndexRange[1] - A * camera.far;\n    return Math.round(A * dist + B);\n  }\n\n  return undefined;\n}\n\nconst epsilon = value => Math.abs(value) < 1e-10 ? 0 : value;\n\nfunction getCSSMatrix(matrix, multipliers, prepend = '') {\n  let matrix3d = 'matrix3d(';\n\n  for (let i = 0; i !== 16; i++) {\n    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? ',' : ')');\n  }\n\n  return prepend + matrix3d;\n}\n\nconst getCameraCSSMatrix = (multipliers => {\n  return matrix => getCSSMatrix(matrix, multipliers);\n})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);\n\nconst getObjectCSSMatrix = (scaleMultipliers => {\n  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');\n})(f => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);\n\nfunction isRefObject(ref) {\n  return ref && typeof ref === 'object' && 'current' in ref;\n}\n\nconst Html = /*#__PURE__*/React.forwardRef(({\n  children,\n  eps = 0.001,\n  style,\n  className,\n  prepend,\n  center,\n  fullscreen,\n  portal,\n  distanceFactor,\n  sprite = false,\n  transform = false,\n  occlude,\n  onOcclude,\n  castShadow,\n  receiveShadow,\n  material,\n  geometry,\n  zIndexRange = [16777271, 0],\n  calculatePosition = defaultCalculatePosition,\n  as = 'div',\n  wrapperClass,\n  pointerEvents = 'auto',\n  ...props\n}, ref) => {\n  const {\n    gl,\n    camera,\n    scene,\n    size,\n    raycaster,\n    events,\n    viewport\n  } = useThree();\n  const [el] = React.useState(() => document.createElement(as));\n  const root = React.useRef();\n  const group = React.useRef(null);\n  const oldZoom = React.useRef(0);\n  const oldPosition = React.useRef([0, 0]);\n  const transformOuterRef = React.useRef(null);\n  const transformInnerRef = React.useRef(null); // Append to the connected element, which makes HTML work with views\n\n  const target = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;\n  const occlusionMeshRef = React.useRef(null);\n  const isMeshSizeSet = React.useRef(false);\n  const isRayCastOcclusion = React.useMemo(() => {\n    return occlude && occlude !== 'blending' || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    const el = gl.domElement;\n\n    if (occlude && occlude === 'blending') {\n      el.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;\n      el.style.position = 'absolute';\n      el.style.pointerEvents = 'none';\n    } else {\n      el.style.zIndex = null;\n      el.style.position = null;\n      el.style.pointerEvents = null;\n    }\n  }, [occlude]);\n  React.useLayoutEffect(() => {\n    if (group.current) {\n      const currentRoot = root.current = ReactDOM.createRoot(el);\n      scene.updateMatrixWorld();\n\n      if (transform) {\n        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;\n      } else {\n        const vec = calculatePosition(group.current, camera, size);\n        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;\n      }\n\n      if (target) {\n        if (prepend) target.prepend(el);else target.appendChild(el);\n      }\n\n      return () => {\n        if (target) target.removeChild(el);\n        currentRoot.unmount();\n      };\n    }\n  }, [target, transform]);\n  React.useLayoutEffect(() => {\n    if (wrapperClass) el.className = wrapperClass;\n  }, [wrapperClass]);\n  const styles = React.useMemo(() => {\n    if (transform) {\n      return {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: size.width,\n        height: size.height,\n        transformStyle: 'preserve-3d',\n        pointerEvents: 'none'\n      };\n    } else {\n      return {\n        position: 'absolute',\n        transform: center ? 'translate3d(-50%,-50%,0)' : 'none',\n        ...(fullscreen && {\n          top: -size.height / 2,\n          left: -size.width / 2,\n          width: size.width,\n          height: size.height\n        }),\n        ...style\n      };\n    }\n  }, [style, center, fullscreen, size, transform]);\n  const transformInnerStyles = React.useMemo(() => ({\n    position: 'absolute',\n    pointerEvents\n  }), [pointerEvents]);\n  React.useLayoutEffect(() => {\n    isMeshSizeSet.current = false;\n\n    if (transform) {\n      var _root$current;\n\n      (_root$current = root.current) == null ? void 0 : _root$current.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformOuterRef,\n        style: styles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: transformInnerRef,\n        style: transformInnerStyles\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        className: className,\n        style: style,\n        children: children\n      }))));\n    } else {\n      var _root$current2;\n\n      (_root$current2 = root.current) == null ? void 0 : _root$current2.render( /*#__PURE__*/React.createElement(\"div\", {\n        ref: ref,\n        style: styles,\n        className: className,\n        children: children\n      }));\n    }\n  });\n  const visible = React.useRef(true);\n  useFrame(gl => {\n    if (group.current) {\n      camera.updateMatrixWorld();\n      group.current.updateWorldMatrix(true, false);\n      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);\n\n      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps || Math.abs(oldPosition.current[0] - vec[0]) > eps || Math.abs(oldPosition.current[1] - vec[1]) > eps) {\n        const isBehindCamera = isObjectBehindCamera(group.current, camera);\n        let raytraceTarget = false;\n\n        if (isRayCastOcclusion) {\n          if (occlude !== 'blending') {\n            raytraceTarget = [scene];\n          } else if (Array.isArray(occlude)) {\n            raytraceTarget = occlude.map(item => item.current);\n          }\n        }\n\n        const previouslyVisible = visible.current;\n\n        if (raytraceTarget) {\n          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);\n          visible.current = isvisible && !isBehindCamera;\n        } else {\n          visible.current = !isBehindCamera;\n        }\n\n        if (previouslyVisible !== visible.current) {\n          if (onOcclude) onOcclude(!visible.current);else el.style.display = visible.current ? 'block' : 'none';\n        }\n\n        const halfRange = Math.floor(zIndexRange[0] / 2);\n        const zRange = occlude ? isRayCastOcclusion //\n        ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;\n        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;\n\n        if (transform) {\n          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];\n          const fov = camera.projectionMatrix.elements[5] * heightHalf;\n          const {\n            isOrthographicCamera,\n            top,\n            left,\n            bottom,\n            right\n          } = camera;\n          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);\n          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;\n          let matrix = group.current.matrixWorld;\n\n          if (sprite) {\n            matrix = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale);\n            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n          }\n\n          el.style.width = size.width + 'px';\n          el.style.height = size.height + 'px';\n          el.style.perspective = isOrthographicCamera ? '' : `${fov}px`;\n\n          if (transformOuterRef.current && transformInnerRef.current) {\n            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;\n            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));\n          }\n        } else {\n          const scale = distanceFactor === undefined ? 1 : objectScale(group.current, camera) * distanceFactor;\n          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`;\n        }\n\n        oldPosition.current = vec;\n        oldZoom.current = camera.zoom;\n      }\n    }\n\n    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {\n      if (transform) {\n        if (transformOuterRef.current) {\n          const el = transformOuterRef.current.children[0];\n\n          if (el != null && el.clientWidth && el != null && el.clientHeight) {\n            const {\n              isOrthographicCamera\n            } = camera;\n\n            if (isOrthographicCamera || geometry) {\n              if (props.scale) {\n                if (!Array.isArray(props.scale)) {\n                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);\n                } else if (props.scale instanceof Vector3) {\n                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));\n                } else {\n                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);\n                }\n              }\n            } else {\n              const ratio = (distanceFactor || 10) / 400;\n              const w = el.clientWidth * ratio;\n              const h = el.clientHeight * ratio;\n              occlusionMeshRef.current.scale.set(w, h, 1);\n            }\n\n            isMeshSizeSet.current = true;\n          }\n        }\n      } else {\n        const ele = el.children[0];\n\n        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {\n          const ratio = 1 / viewport.factor;\n          const w = ele.clientWidth * ratio;\n          const h = ele.clientHeight * ratio;\n          occlusionMeshRef.current.scale.set(w, h, 1);\n          isMeshSizeSet.current = true;\n        }\n\n        occlusionMeshRef.current.lookAt(gl.camera.position);\n      }\n    }\n  });\n  const shaders = React.useMemo(() => ({\n    vertexShader: !transform ?\n    /* glsl */\n    `\n          /*\n            This shader is from the THREE's SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if \"transfrom\" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ` : undefined,\n    fragmentShader:\n    /* glsl */\n    `\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `\n  }), [transform]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: group\n  }), occlude && !isRayCastOcclusion && /*#__PURE__*/React.createElement(\"mesh\", {\n    castShadow: castShadow,\n    receiveShadow: receiveShadow,\n    ref: occlusionMeshRef\n  }, geometry || /*#__PURE__*/React.createElement(\"planeGeometry\", null), material || /*#__PURE__*/React.createElement(\"shaderMaterial\", {\n    side: DoubleSide,\n    vertexShader: shaders.vertexShader,\n    fragmentShader: shaders.fragmentShader\n  })));\n});\n\nexport { Html };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}