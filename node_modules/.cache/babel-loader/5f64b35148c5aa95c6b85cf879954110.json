{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LLkLookaheadStrategy = void 0;\n\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar errors_public_1 = require(\"../errors_public\");\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar checks_1 = require(\"./checks\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar LLkLookaheadStrategy =\n/** @class */\nfunction () {\n  function LLkLookaheadStrategy(options) {\n    var _a;\n\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n\n  LLkLookaheadStrategy.prototype.validate = function (options) {\n    var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n      var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n\n      var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n\n      return allErrors;\n    }\n\n    return leftRecursionErrors;\n  };\n\n  LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n    return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n  };\n\n  LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n  };\n\n  LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n  };\n\n  return LLkLookaheadStrategy;\n}();\n\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAQA;;AACA;;AACA;;AACA;;AACA;;AAMA;;AASA;AAAA;AAAA;EAGE,8BAAYA,OAAZ,EAA+C;;;IAC7C,KAAKC,YAAL,GACE,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEA,YAAT,MAAqB,IAArB,IAAqBC,aAArB,GAAqBA,EAArB,GAAyBC,+BAAsBF,YADjD;EAED;;EAEDG,oDAASJ,OAAT,EAIC;IACC,IAAMK,mBAAmB,GAAG,KAAKC,uBAAL,CAA6BN,OAAO,CAACO,KAArC,CAA5B;;IAEA,IAAI,uBAAQF,mBAAR,CAAJ,EAAkC;MAChC,IAAMG,cAAc,GAAG,KAAKC,2BAAL,CAAiCT,OAAO,CAACO,KAAzC,CAAvB;MACA,IAAMG,mBAAmB,GAAG,KAAKC,wCAAL,CAC1BX,OAAO,CAACO,KADkB,EAE1B,KAAKN,YAFqB,CAA5B;MAIA,IAAMW,qBAAqB,GAAG,KAAKC,iCAAL,CAC5Bb,OAAO,CAACO,KADoB,EAE5B,KAAKN,YAFuB,CAA9B;;MAIA,IAAMa,SAAS,+DACVT,mBADU,EACS,IADT,GAEVG,cAFU,EAEI,IAFJ,GAGVE,mBAHU,EAGS,IAHT,GAIVE,qBAJU,EAIW,IAJX,CAAf;;MAMA,OAAOE,SAAP;IACD;;IACD,OAAOT,mBAAP;EACD,CA1BD;;EA4BAD,mEAAwBG,KAAxB,EAAqC;IACnC,OAAO,uBAAQA,KAAR,EAAe,UAACQ,WAAD,EAAY;MAChC,6CACEA,WADF,EAEEA,WAFF,EAGEC,oDAHF;IAIC,CALI,CAAP;EAOD,CARD;;EAUAZ,uEAA4BG,KAA5B,EAAyC;IACvC,OAAO,uBAAQA,KAAR,EAAe,UAACQ,WAAD,EAAY;MAChC,gDACEA,WADF,EAEEC,oDAFF;IAGC,CAJI,CAAP;EAMD,CAPD;;EASAZ,oFACEG,KADF,EAEEN,YAFF,EAEsB;IAEpB,OAAO,uBAAQM,KAAR,EAAe,UAACQ,WAAD,EAAY;MAChC,8DACEA,WADF,EAEEd,YAFF,EAGEe,oDAHF;IAIC,CALI,CAAP;EAOD,CAXD;;EAaAZ,6EACEG,KADF,EAEEN,YAFF,EAEsB;IAEpB,OAAO,gDACLM,KADK,EAELN,YAFK,EAGLe,oDAHK,CAAP;EAKD,CATD;;EAWAZ,wEAA6BJ,OAA7B,EAMC;IACC,OAAO,yCACLA,OAAO,CAACiB,cADH,EAELjB,OAAO,CAACkB,IAFH,EAGLlB,OAAO,CAACC,YAHH,EAILD,OAAO,CAACmB,aAJH,EAKLnB,OAAO,CAACoB,oBALH,EAMLC,0CANK,CAAP;EAQD,CAfD;;EAiBAjB,qEAA0BJ,OAA1B,EAMC;IACC,OAAO,mDACLA,OAAO,CAACiB,cADH,EAELjB,OAAO,CAACkB,IAFH,EAGLlB,OAAO,CAACC,YAHH,EAILD,OAAO,CAACoB,oBAJH,EAKL,6BAAYpB,OAAO,CAACsB,QAApB,CALK,EAMLD,mDANK,CAAP;EAQD,CAfD;;EAgBF;AAAC,CAhHD;;AAAaE","names":["options","maxLookahead","_a","parser_1","LLkLookaheadStrategy","leftRecursionErrors","validateNoLeftRecursion","rules","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","validateAmbiguousAlternationAlternatives","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","allErrors","currTopRule","errors_public_1","prodOccurrence","rule","hasPredicates","dynamicTokensEnabled","lookahead_1","prodType","exports"],"sources":["/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts"],"sourcesContent":["import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  Rule,\n  TokenType,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport flatMap from \"lodash/flatMap\"\nimport isEmpty from \"lodash/isEmpty\"\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser\"\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath\n} from \"./checks\"\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType\n} from \"./lookahead\"\nimport { IParserDefinitionError } from \"./types\"\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead\n  }\n\n  validate(options: {\n    rules: Rule[]\n    tokenTypes: TokenType[]\n    grammarName: string\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead\n      )\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead\n      )\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ]\n      return allErrors\n    }\n    return leftRecursionErrors\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider\n    )\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number\n    rule: Rule\n    maxLookahead: number\n    hasPredicates: boolean\n    dynamicTokensEnabled: boolean\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc\n    )\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number\n    prodType: OptionalProductionType\n    rule: Rule\n    maxLookahead: number\n    dynamicTokensEnabled: boolean\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}