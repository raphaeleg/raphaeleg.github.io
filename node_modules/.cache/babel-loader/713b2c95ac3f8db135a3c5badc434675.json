{"ast":null,"code":"import _objectSpread from \"/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar aabb = /* @__PURE__ */new Box3();\nvar aabb2 = /* @__PURE__ */new Box3();\nvar tempMatrix = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nvar temp = /* @__PURE__ */new Vector3();\nvar temp1 = /* @__PURE__ */new Vector3();\nvar temp2 = /* @__PURE__ */new Vector3();\nvar temp3 = /* @__PURE__ */new Vector3();\nvar temp4 = /* @__PURE__ */new Vector3();\nvar tempBox = /* @__PURE__ */new Box3();\nvar trianglePool = /* @__PURE__ */new PrimitivePool(function () {\n  return new ExtendedTriangle();\n});\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MeshBVH);\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null\n    }, SKIP_GENERATION, false), options);\n\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n\n        _traverse(0, byteOffset);\n\n        byteOffset += buffer.byteLength;\n      }\n\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i];\n            var x = posAttr.getX(index);\n            var y = posAttr.getY(index);\n            var z = posAttr.getZ(index);\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6]; // the identifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var forceChildren = force;\n          var includesLeft = false;\n          var includesRight = false;\n\n          if (nodeIndices) {\n            // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            if (!forceChildren) {\n              includesLeft = nodeIndices.has(offsetLeft);\n              includesRight = nodeIndices.has(offsetRight);\n              forceChildren = !includesLeft && !includesRight;\n            }\n          } else {\n            includesLeft = true;\n            includesRight = true;\n          }\n\n          var traverseLeft = forceChildren || includesLeft;\n          var traverseRight = forceChildren || includesRight;\n          var leftChange = false;\n\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceChildren);\n          }\n\n          var rightChange = false;\n\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceChildren);\n          }\n\n          var didChange = leftChange || rightChange;\n\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n\n      _traverse(0);\n\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n    /* Core Cast Functions */\n\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        setBuffer(roots[i]);\n\n        _raycast(0, geometry, materialSide, ray, intersects);\n\n        clearBuffer();\n\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        setBuffer(roots[i]);\n\n        var result = _raycastFirst(0, geometry, materialSide, ray);\n\n        clearBuffer();\n\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n\n      var _iterator = _createForOfIteratorHelper(this._roots),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n\n      var triangle = trianglePool.getPrimitive();\n      var _callbacks = callbacks,\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n          intersectsBounds = _callbacks.intersectsBounds,\n          intersectsRange = _callbacks.intersectsRange,\n          intersectsTriangle = _callbacks.intersectsTriangle;\n\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      var result = false;\n      var byteOffset = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      trianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n      // than an approach that walks down the tree (see bvhcast.js file for more info).\n      var intersectsRanges = callbacks.intersectsRanges,\n          intersectsTriangles = callbacks.intersectsTriangles;\n      var indexAttr = this.geometry.index;\n      var positionAttr = this.geometry.attributes.position;\n      var otherIndexAttr = otherBvh.geometry.index;\n      var otherPositionAttr = otherBvh.geometry.attributes.position;\n      tempMatrix.copy(matrixToLocal).invert();\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n              triangle.needsUpdate = true;\n\n              if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n\n      otherBvh.getBoundingBox(aabb2);\n      aabb2.applyMatrix4(matrixToLocal);\n      var result = this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return aabb2.intersectsBox(box);\n        },\n        intersectsRange: function intersectsRange(offset1, count1, contained, depth1, nodeIndex1, box) {\n          aabb.copy(box);\n          aabb.applyMatrix4(tempMatrix);\n          return otherBvh.shapecast({\n            intersectsBounds: function intersectsBounds(box) {\n              return aabb.intersectsBox(box);\n            },\n            intersectsRange: function intersectsRange(offset2, count2, contained, depth2, nodeIndex2) {\n              return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n            }\n          });\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      return result;\n    }\n    /* Derived Cast Functions */\n\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      var tempTarget1 = temp1;\n      var tempTargetDest1 = temp2;\n      var tempTarget2 = null;\n      var tempTargetDest2 = null;\n\n      if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n      }\n\n      var closestDistance = Infinity;\n      var closestDistanceTriIndex = null;\n      var closestDistanceOtherTriIndex = null;\n      tempMatrix.copy(geometryToBvh).invert();\n      obb2.matrix.copy(tempMatrix);\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast({\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box);\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                    if (dist < closestDistance) {\n                      tempTargetDest1.copy(tempTarget1);\n\n                      if (tempTargetDest2) {\n                        tempTargetDest2.copy(tempTarget2);\n                      }\n\n                      closestDistance = dist;\n                      closestDistanceTriIndex = i / 3;\n                      closestDistanceOtherTriIndex = i2 / 3;\n                    } // stop traversal if we find a point that's under the given threshold\n\n\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i / 3;\n                  closestDistanceOtherTriIndex = i2 / 3;\n                } // stop traversal if we find a point that's under the given threshold\n\n\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      if (closestDistance === Infinity) return null;\n      if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n      target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n\n      if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n      }\n\n      return target1;\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      var closestDistanceTriIndex = null;\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri, triIndex) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n\n          if (distSq < closestDistanceSq) {\n            temp1.copy(temp);\n            closestDistanceSq = distSq;\n            closestDistanceTriIndex = triIndex;\n          }\n\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      if (closestDistanceSq === Infinity) return null;\n      var closestDistance = Math.sqrt(closestDistanceSq);\n      if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n      target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n      return target;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.isBufferGeometry) {\n        console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.serialize(arguments[0], {\n          cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result;\n\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice()\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array\n        };\n      }\n\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (typeof options === 'boolean') {\n        console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.deserialize(arguments[0], arguments[1], {\n          setIndex: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        setIndex: true\n      }, options);\n      var index = data.index,\n          roots = data.roots;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n\n      return bvh;\n    }\n  }]);\n\n  return MeshBVH;\n}();","map":{"version":3,"names":["Vector3","BufferAttribute","Box3","FrontSide","Matrix4","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","OrientedBox","ExtendedTriangle","PrimitivePool","arrayToBox","iterateOverTriangles","setTriangle","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","obb","obb2","temp","temp1","temp2","temp3","temp4","tempBox","trianglePool","MeshBVH","geometry","options","isBufferGeometry","Error","index","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","_roots","boundingBox","getBoundingBox","nodeIndices","Array","isArray","Set","indexArr","array","posAttr","attributes","position","buffer","uint32Array","uint16Array","float32Array","byteOffset","roots","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","offset","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","getX","y","getY","z","getZ","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","depth","splitAxis","stopTraversal","ray","materialOrSide","intersects","isMaterial","isArrayMaterial","groups","side","materialSide","materialIndex","startCount","j","jl","face","closestResult","result","distance","otherGeometry","geomToMesh","root","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","console","warn","triangle","getPrimitive","originalIntersectsRange","nodeIndex","releasePrimitive","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","copy","invert","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","a","applyMatrix4","b","c","needsUpdate","i1","l1","originalIntersectsRanges","box","intersectsBox","nodeIndex1","nodeIndex2","boxToMesh","set","min","max","sphere","intersectsSphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","matrix","distanceToBox","score","boundsTree","otherOffset","otherCount","dist","distanceToTriangle","triCount","point","clone","faceIndex","sub","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","triIndex","closestPointToPoint","distSq","Math","sqrt","makeEmpty","forEach","union","bvh","serialize","arguments","cloneBuffers","undefined","rootData","indexAttribute","getIndex","map","slice","data","deserialize","setIndex","newIndex"],"sources":["/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}