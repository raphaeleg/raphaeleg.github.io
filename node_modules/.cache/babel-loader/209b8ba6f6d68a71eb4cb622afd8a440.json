{"ast":null,"code":"import _classCallCheck from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _construct from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"temporal\", \"frames\", \"limit\", \"blend\", \"scale\", \"opacity\", \"alphaTest\", \"color\", \"colorBlend\", \"resolution\", \"toneMapped\"],\n    _excluded2 = [\"castShadow\", \"bias\", \"mapSize\", \"size\", \"near\", \"far\", \"frames\", \"position\", \"radius\", \"amount\", \"intensity\", \"ambient\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nvar accumulativeContext = /*#__PURE__*/React.createContext(null);\nvar SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, \"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\", \"varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <encodings_fragment>\\n   }\");\nvar AccumulativeShadows = /*#__PURE__*/React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n      temporal = _ref.temporal,\n      _ref$frames = _ref.frames,\n      frames = _ref$frames === void 0 ? 40 : _ref$frames,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? Infinity : _ref$limit,\n      _ref$blend = _ref.blend,\n      blend = _ref$blend === void 0 ? 20 : _ref$blend,\n      _ref$scale = _ref.scale,\n      scale = _ref$scale === void 0 ? 10 : _ref$scale,\n      _ref$opacity = _ref.opacity,\n      opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,\n      _ref$alphaTest = _ref.alphaTest,\n      alphaTest = _ref$alphaTest === void 0 ? 0.75 : _ref$alphaTest,\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'black' : _ref$color,\n      _ref$colorBlend = _ref.colorBlend,\n      colorBlend = _ref$colorBlend === void 0 ? 2 : _ref$colorBlend,\n      _ref$resolution = _ref.resolution,\n      resolution = _ref$resolution === void 0 ? 1024 : _ref$resolution,\n      _ref$toneMapped = _ref.toneMapped,\n      toneMapped = _ref$toneMapped === void 0 ? true : _ref$toneMapped,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  extend({\n    SoftShadowMaterial: SoftShadowMaterial\n  });\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var camera = useThree(function (state) {\n    return state.camera;\n  });\n  var invalidate = useThree(function (state) {\n    return state.invalidate;\n  });\n  var gPlane = React.useRef(null);\n  var gLights = React.useRef(null);\n\n  var _React$useState = React.useState(function () {\n    return new ProgressiveLightMap(gl, scene, resolution);\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 1),\n      plm = _React$useState2[0];\n\n  React.useLayoutEffect(function () {\n    plm.configure(gPlane.current);\n  }, []);\n  var api = React.useMemo(function () {\n    return {\n      lights: new Map(),\n      temporal: !!temporal,\n      frames: Math.max(2, frames),\n      blend: Math.max(2, frames === Infinity ? blend : frames),\n      count: 0,\n      getMesh: function getMesh() {\n        return gPlane.current;\n      },\n      reset: function reset() {\n        // Clear buffers, reset opacities, set frame count to 0\n        plm.clear();\n        var material = gPlane.current.material;\n        material.opacity = 0;\n        material.alphaTest = 0;\n        api.count = 0;\n      },\n      update: function update() {\n        var frames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        // Adapt the opacity-blend ratio to the number of frames\n        var material = gPlane.current.material;\n\n        if (!api.temporal) {\n          material.opacity = opacity;\n          material.alphaTest = alphaTest;\n        } else {\n          material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n          material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n        } // Switch accumulative lights on\n\n\n        gLights.current.visible = true; // Collect scene lights and meshes\n\n        plm.prepare(); // Update the lightmap and the accumulative lights\n\n        for (var i = 0; i < frames; i++) {\n          api.lights.forEach(function (light) {\n            return light.update();\n          });\n          plm.update(camera, api.blend);\n        } // Switch lights off\n\n\n        gLights.current.visible = false; // Restore lights and meshes\n\n        plm.finish();\n      }\n    };\n  }, [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(function () {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  useFrame(function () {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: function traverse() {\n      return null;\n    },\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nvar RandomizedLight = /*#__PURE__*/React.forwardRef(function (_ref2, forwardRef) {\n  var _ref2$castShadow = _ref2.castShadow,\n      castShadow = _ref2$castShadow === void 0 ? true : _ref2$castShadow,\n      _ref2$bias = _ref2.bias,\n      bias = _ref2$bias === void 0 ? 0.001 : _ref2$bias,\n      _ref2$mapSize = _ref2.mapSize,\n      mapSize = _ref2$mapSize === void 0 ? 512 : _ref2$mapSize,\n      _ref2$size = _ref2.size,\n      size = _ref2$size === void 0 ? 5 : _ref2$size,\n      _ref2$near = _ref2.near,\n      near = _ref2$near === void 0 ? 0.5 : _ref2$near,\n      _ref2$far = _ref2.far,\n      far = _ref2$far === void 0 ? 500 : _ref2$far,\n      _ref2$frames = _ref2.frames,\n      frames = _ref2$frames === void 0 ? 1 : _ref2$frames,\n      _ref2$position = _ref2.position,\n      position = _ref2$position === void 0 ? [0, 0, 0] : _ref2$position,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === void 0 ? 1 : _ref2$radius,\n      _ref2$amount = _ref2.amount,\n      amount = _ref2$amount === void 0 ? 8 : _ref2$amount,\n      _ref2$intensity = _ref2.intensity,\n      intensity = _ref2$intensity === void 0 ? 1 : _ref2$intensity,\n      _ref2$ambient = _ref2.ambient,\n      ambient = _ref2$ambient === void 0 ? 0.5 : _ref2$ambient,\n      props = _objectWithoutProperties(_ref2, _excluded2);\n\n  var gLights = React.useRef(null);\n\n  var length = _construct(THREE.Vector3, _toConsumableArray(position)).length();\n\n  var parent = React.useContext(accumulativeContext);\n  var update = React.useCallback(function () {\n    var light;\n\n    if (gLights.current) {\n      for (var l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          var lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          var phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length].concat(_toConsumableArray(position)));\n  var api = React.useMemo(function () {\n    return {\n      update: update\n    };\n  }, [update]);\n  React.useImperativeHandle(forwardRef, function () {\n    return api;\n  }, [api]);\n  React.useLayoutEffect(function () {\n    var group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return function () {\n      return void parent.lights.delete(group.uuid);\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, function (_, index) {\n    return /*#__PURE__*/React.createElement(\"directionalLight\", {\n      key: index,\n      castShadow: castShadow,\n      \"shadow-bias\": bias,\n      \"shadow-mapSize\": [mapSize, mapSize],\n      intensity: intensity / amount\n    }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n      attach: \"shadow-camera\",\n      args: [-size, size, size, -size, near, far]\n    }));\n  }));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer, scene) {\n    var _this = this;\n\n    var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1024;\n\n    _classCallCheck(this, ProgressiveLightMap);\n\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0; // Create the Progressive LightMap Texture\n\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = function (shader) {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\\n      }\"; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = _this.previousShadowMap;\n      shader.uniforms.averagingWindow = _this.averagingWindow;\n    };\n  }\n\n  _createClass(ProgressiveLightMap, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n\n      this.renderer.getClearColor(this.clearColor);\n      this.clearAlpha = this.renderer.getClearAlpha();\n      this.renderer.setClearColor('black', 1);\n      this.renderer.setRenderTarget(this.progressiveLightMap1);\n      this.renderer.clear();\n      this.renderer.setRenderTarget(this.progressiveLightMap2);\n      this.renderer.clear();\n      this.renderer.setRenderTarget(null);\n      this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n      this.lights = [];\n      this.meshes = [];\n      this.scene.traverse(function (object) {\n        if (isGeometry(object)) {\n          _this2.meshes.push({\n            object: object,\n            material: object.material\n          });\n        } else if (isLight(object)) {\n          _this2.lights.push({\n            object: object,\n            intensity: object.intensity\n          });\n        }\n      });\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare() {\n      var _this3 = this;\n\n      this.lights.forEach(function (light) {\n        return light.object.intensity = 0;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = _this3.discardMat;\n      });\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.lights.forEach(function (light) {\n        return light.object.intensity = light.intensity;\n      });\n      this.meshes.forEach(function (mesh) {\n        return mesh.object.material = mesh.material;\n      });\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(object) {\n      this.object = object;\n    }\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n      this.averagingWindow.value = blendWindow;\n      this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n      var oldBg = this.scene.background;\n      this.scene.background = null;\n      this.renderer.setRenderTarget(activeMap);\n      this.previousShadowMap.value = inactiveMap.texture;\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n      this.renderer.setRenderTarget(null);\n      this.scene.background = oldBg;\n    }\n  }]);\n\n  return ProgressiveLightMap;\n}();\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","shaderMaterial","DiscardMaterial","isLight","object","isGeometry","geometry","accumulativeContext","createContext","SoftShadowMaterial","color","Color","blend","alphaTest","opacity","map","AccumulativeShadows","forwardRef","children","temporal","frames","limit","Infinity","scale","colorBlend","resolution","toneMapped","props","gl","state","scene","camera","invalidate","gPlane","useRef","gLights","useState","ProgressiveLightMap","plm","useLayoutEffect","configure","current","api","useMemo","lights","Map","Math","max","count","getMesh","reset","clear","material","update","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","value","receiveShadow","rotation","PI","transparent","depthWrite","progressiveLightMap2","texture","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","renderer","res","buffer1Active","meshes","clearColor","clearAlpha","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","discardMat","targetMat","MeshLambertMaterial","fog","previousShadowMap","averagingWindow","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","uniforms","getClearColor","getClearAlpha","setClearColor","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","oldBg","background","render"],"sources":["/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const invalidate = useThree(state => state.invalidate);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}