{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\n/*  Integration and compilation: @N8Programs\n    Inspired by:\n     https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shadowmap_pcss.html\n     https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-17-efficient-soft-edged-shadows-using\n     https://developer.download.nvidia.com/whitepapers/2008/PCSS_Integration.pdf\n     https://github.com/mrdoob/three.js/blob/master/examples/webgl_shadowmap_pcss.html [spidersharma03]\n     https://spline.design/\n   Concept:\n     https://www.gamedev.net/tutorials/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n   Vogel Disk Implementation:\n     https://www.shadertoy.com/view/4l3yRM [ashalah]\n   High-Frequency Noise Implementation:\n     https://www.shadertoy.com/view/tt3fDH [spawner64]\n*/\n\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$focus = _ref.focus,\n      focus = _ref$focus === void 0 ? 0 : _ref$focus,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 25 : _ref$size,\n      _ref$samples = _ref.samples,\n      samples = _ref$samples === void 0 ? 10 : _ref$samples;\n\n  return \"\\n#define PENUMBRA_FILTER_SIZE float(\".concat(size, \")\\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\\nvec3 randRGB(vec2 uv) {\\n  return vec3(\\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\\n  );\\n}\\n\\nvec3 lowPassRandRGB(vec2 uv) {\\n  // 3x3 convolution (average)\\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\\n  vec3 result = vec3(0);\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\\n  result *= 0.111111111; // 1.0 / 9.0\\n  return result;\\n}\\nvec3 highPassRandRGB(vec2 uv) {\\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\\n  // hp(x) = x - lp(x)\\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\\n}\\n\\n\\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\\n  const float goldenAngle = 2.399963f; // radians\\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\\n  float theta = float(sampleIndex) * goldenAngle + angle;\\n  float sine = sin(theta);\\n  float cosine = cos(theta);\\n  return vec2(cosine, sine) * r;\\n}\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float blockerDepthSum = float(\").concat(focus, \");\\n  float blockers = 0.0;\\n\\n  int j = 0;\\n  vec2 offset = vec2(0.);\\n  float depth = 0.;\\n\\n  #pragma unroll_loop_start\\n  for(int i = 0; i < \").concat(samples, \"; i ++) {\\n    offset = (vogelDiskSample(j, \").concat(samples, \", angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\\n    if (depth < compare) {\\n      blockerDepthSum += depth;\\n      blockers++;\\n    }\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n\\n  if (blockers > 0.0) {\\n    return blockerDepthSum / blockers;\\n  }\\n  return -1.0;\\n}\\n\\n        \\nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float shadow = 0.0f;\\n  int j = 0;\\n  vec2 vogelSample = vec2(0.0);\\n  vec2 offset = vec2(0.0);\\n  #pragma unroll_loop_start\\n  for (int i = 0; i < \").concat(samples, \"; i++) {\\n    vogelSample = vogelDiskSample(j, \").concat(samples, \", angle) * texelSize;\\n    offset = vogelSample * (1.0 + filterRadius * float(\").concat(size, \"));\\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n  return shadow * 1.0 / \").concat(samples, \".0;\\n}\\n\\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\\n  if (avgBlockerDepth == -1.0) {\\n    return 1.0;\\n  }\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\\n}\");\n};\n\nfunction reset(gl, scene, camera) {\n  scene.traverse(function (object) {\n    if (object.material) {\n      gl.properties.remove(object.material);\n      object.material.dispose == null ? void 0 : object.material.dispose();\n    }\n  });\n  gl.info.programs.length = 0;\n  gl.compile(scene, camera);\n}\n\nfunction SoftShadows(_ref2) {\n  var _ref2$focus = _ref2.focus,\n      focus = _ref2$focus === void 0 ? 0 : _ref2$focus,\n      _ref2$samples = _ref2.samples,\n      samples = _ref2$samples === void 0 ? 10 : _ref2$samples,\n      _ref2$size = _ref2.size,\n      size = _ref2$size === void 0 ? 25 : _ref2$size;\n  var gl = useThree(function (state) {\n    return state.gl;\n  });\n  var scene = useThree(function (state) {\n    return state.scene;\n  });\n  var camera = useThree(function (state) {\n    return state.camera;\n  });\n  React.useEffect(function () {\n    var original = THREE.ShaderChunk.shadowmap_pars_fragment;\n    THREE.ShaderChunk.shadowmap_pars_fragment = THREE.ShaderChunk.shadowmap_pars_fragment.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({\n      size: size,\n      samples: samples,\n      focus: focus\n    })).replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    reset(gl, scene, camera);\n    return function () {\n      THREE.ShaderChunk.shadowmap_pars_fragment = original;\n      reset(gl, scene, camera);\n    };\n  }, [focus, size, samples]);\n  return null;\n}\n\nexport { SoftShadows };","map":{"version":3,"names":["React","THREE","useThree","pcss","focus","size","samples","reset","gl","scene","camera","traverse","object","material","properties","remove","dispose","info","programs","length","compile","SoftShadows","state","useEffect","original","ShaderChunk","shadowmap_pars_fragment","replace"],"sources":["/Users/crushedsummers/Documents/GitHub/raphaeleg.github.io/node_modules/@react-three/drei/core/softShadows.js"],"sourcesContent":["import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\n\n/*  Integration and compilation: @N8Programs\n    Inspired by:\n     https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shadowmap_pcss.html\n     https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-17-efficient-soft-edged-shadows-using\n     https://developer.download.nvidia.com/whitepapers/2008/PCSS_Integration.pdf\n     https://github.com/mrdoob/three.js/blob/master/examples/webgl_shadowmap_pcss.html [spidersharma03]\n     https://spline.design/\n   Concept:\n     https://www.gamedev.net/tutorials/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/\n   Vogel Disk Implementation:\n     https://www.shadertoy.com/view/4l3yRM [ashalah]\n   High-Frequency Noise Implementation:\n     https://www.shadertoy.com/view/tt3fDH [spawner64]\n*/\n\nconst pcss = ({\n  focus = 0,\n  size = 25,\n  samples = 10\n} = {}) => `\n#define PENUMBRA_FILTER_SIZE float(${size})\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\nvec3 randRGB(vec2 uv) {\n  return vec3(\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n  );\n}\n\nvec3 lowPassRandRGB(vec2 uv) {\n  // 3x3 convolution (average)\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n  vec3 result = vec3(0);\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n  result *= 0.111111111; // 1.0 / 9.0\n  return result;\n}\nvec3 highPassRandRGB(vec2 uv) {\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n  // hp(x) = x - lp(x)\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n}\n\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float blockerDepthSum = float(${focus});\n  float blockers = 0.0;\n\n  int j = 0;\n  vec2 offset = vec2(0.);\n  float depth = 0.;\n\n  #pragma unroll_loop_start\n  for(int i = 0; i < ${samples}; i ++) {\n    offset = (vogelDiskSample(j, ${samples}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n    if (depth < compare) {\n      blockerDepthSum += depth;\n      blockers++;\n    }\n    j++;\n  }\n  #pragma unroll_loop_end\n\n  if (blockers > 0.0) {\n    return blockerDepthSum / blockers;\n  }\n  return -1.0;\n}\n\n        \nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float shadow = 0.0f;\n  int j = 0;\n  vec2 vogelSample = vec2(0.0);\n  vec2 offset = vec2(0.0);\n  #pragma unroll_loop_start\n  for (int i = 0; i < ${samples}; i++) {\n    vogelSample = vogelDiskSample(j, ${samples}, angle) * texelSize;\n    offset = vogelSample * (1.0 + filterRadius * float(${size}));\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    j++;\n  }\n  #pragma unroll_loop_end\n  return shadow * 1.0 / ${samples}.0;\n}\n\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n  if (avgBlockerDepth == -1.0) {\n    return 1.0;\n  }\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n}`;\n\nfunction reset(gl, scene, camera) {\n  scene.traverse(object => {\n    if (object.material) {\n      gl.properties.remove(object.material);\n      object.material.dispose == null ? void 0 : object.material.dispose();\n    }\n  });\n  gl.info.programs.length = 0;\n  gl.compile(scene, camera);\n}\n\nfunction SoftShadows({\n  focus = 0,\n  samples = 10,\n  size = 25\n}) {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  React.useEffect(() => {\n    const original = THREE.ShaderChunk.shadowmap_pars_fragment;\n    THREE.ShaderChunk.shadowmap_pars_fragment = THREE.ShaderChunk.shadowmap_pars_fragment.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({\n      size,\n      samples,\n      focus\n    })).replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    reset(gl, scene, camera);\n    return () => {\n      THREE.ShaderChunk.shadowmap_pars_fragment = original;\n      reset(gl, scene, camera);\n    };\n  }, [focus, size, samples]);\n  return null;\n}\n\nexport { SoftShadows };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,QAAT,QAAyB,oBAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,IAAI,GAAG,SAAPA,IAAO;EAAA,+EAIT,EAJS;EAAA,sBACXC,KADW;EAAA,IACXA,KADW,2BACH,CADG;EAAA,qBAEXC,IAFW;EAAA,IAEXA,IAFW,0BAEJ,EAFI;EAAA,wBAGXC,OAHW;EAAA,IAGXA,OAHW,6BAGD,EAHC;;EAAA,sDAKwBD,IALxB,o7DAmDqBD,KAnDrB,8JA2DUE,OA3DV,yDA4DsBA,OA5DtB,yqBAoFWA,OApFX,4DAqF0BA,OArF1B,2FAsF4CD,IAtF5C,gLA2FaC,OA3Fb;AAAA,CAAb;;AA0GA,SAASC,KAAT,CAAeC,EAAf,EAAmBC,KAAnB,EAA0BC,MAA1B,EAAkC;EAChCD,KAAK,CAACE,QAAN,CAAe,UAAAC,MAAM,EAAI;IACvB,IAAIA,MAAM,CAACC,QAAX,EAAqB;MACnBL,EAAE,CAACM,UAAH,CAAcC,MAAd,CAAqBH,MAAM,CAACC,QAA5B;MACAD,MAAM,CAACC,QAAP,CAAgBG,OAAhB,IAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2CJ,MAAM,CAACC,QAAP,CAAgBG,OAAhB,EAA3C;IACD;EACF,CALD;EAMAR,EAAE,CAACS,IAAH,CAAQC,QAAR,CAAiBC,MAAjB,GAA0B,CAA1B;EACAX,EAAE,CAACY,OAAH,CAAWX,KAAX,EAAkBC,MAAlB;AACD;;AAED,SAASW,WAAT,QAIG;EAAA,wBAHDjB,KAGC;EAAA,IAHDA,KAGC,4BAHO,CAGP;EAAA,0BAFDE,OAEC;EAAA,IAFDA,OAEC,8BAFS,EAET;EAAA,uBADDD,IACC;EAAA,IADDA,IACC,2BADM,EACN;EACD,IAAMG,EAAE,GAAGN,QAAQ,CAAC,UAAAoB,KAAK;IAAA,OAAIA,KAAK,CAACd,EAAV;EAAA,CAAN,CAAnB;EACA,IAAMC,KAAK,GAAGP,QAAQ,CAAC,UAAAoB,KAAK;IAAA,OAAIA,KAAK,CAACb,KAAV;EAAA,CAAN,CAAtB;EACA,IAAMC,MAAM,GAAGR,QAAQ,CAAC,UAAAoB,KAAK;IAAA,OAAIA,KAAK,CAACZ,MAAV;EAAA,CAAN,CAAvB;EACAV,KAAK,CAACuB,SAAN,CAAgB,YAAM;IACpB,IAAMC,QAAQ,GAAGvB,KAAK,CAACwB,WAAN,CAAkBC,uBAAnC;IACAzB,KAAK,CAACwB,WAAN,CAAkBC,uBAAlB,GAA4CzB,KAAK,CAACwB,WAAN,CAAkBC,uBAAlB,CAA0CC,OAA1C,CAAkD,sBAAlD,EAA0E,2BAA2BxB,IAAI,CAAC;MACpJE,IAAI,EAAJA,IADoJ;MAEpJC,OAAO,EAAPA,OAFoJ;MAGpJF,KAAK,EAALA;IAHoJ,CAAD,CAAzG,EAIxCuB,OAJwC,CAIhC,mCAJgC,EAIK,2EAJL,CAA5C;IAKApB,KAAK,CAACC,EAAD,EAAKC,KAAL,EAAYC,MAAZ,CAAL;IACA,OAAO,YAAM;MACXT,KAAK,CAACwB,WAAN,CAAkBC,uBAAlB,GAA4CF,QAA5C;MACAjB,KAAK,CAACC,EAAD,EAAKC,KAAL,EAAYC,MAAZ,CAAL;IACD,CAHD;EAID,CAZD,EAYG,CAACN,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAZH;EAaA,OAAO,IAAP;AACD;;AAED,SAASe,WAAT"},"metadata":{},"sourceType":"module"}