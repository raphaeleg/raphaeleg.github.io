{"ast":null,"code":"import { elementTransitionEnd, now } from '../../shared/utils.js';\nexport default function freeMode(_ref) {\n  var swiper = _ref.swiper,\n      extendParams = _ref.extendParams,\n      emit = _ref.emit,\n      once = _ref.once;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n\n  function onTouchStart() {\n    var translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n\n  function onTouchMove() {\n    var data = swiper.touchEventsData,\n        touches = swiper.touches; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n\n  function onTouchEnd(_ref2) {\n    var currentPos = _ref2.currentPos;\n    var params = swiper.params,\n        wrapperEl = swiper.wrapperEl,\n        rtl = swiper.rtlTranslate,\n        snapGrid = swiper.snapGrid,\n        data = swiper.touchEventsData; // Time diff\n\n    var touchEndTime = now();\n    var timeDiff = touchEndTime - data.touchStartTime;\n\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        var lastMoveEvent = data.velocities.pop();\n        var velocityEvent = data.velocities.pop();\n        var distance = lastMoveEvent.position - velocityEvent.position;\n        var time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      var momentumDuration = 1000 * params.freeMode.momentumRatio;\n      var momentumDistance = swiper.velocity * momentumDuration;\n      var newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      var doBounce = false;\n      var afterBouncePosition;\n      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      var needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        var nextSlide;\n\n        for (var j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        once('transitionEnd', function () {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, function () {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(function () {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, function () {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, function () {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart: onTouchStart,\n      onTouchMove: onTouchMove,\n      onTouchEnd: onTouchEnd\n    }\n  });\n}","map":{"version":3,"names":["elementTransitionEnd","now","freeMode","swiper","extendParams","emit","once","enabled","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","sticky","minimumVelocity","onTouchStart","translate","getTranslate","setTranslate","setTransition","touchEventsData","velocities","length","onTouchEnd","currentPos","rtl","onTouchMove","data","touches","push","position","isHorizontal","time","touchStartTime","params","wrapperEl","rtlTranslate","snapGrid","touchEndTime","timeDiff","minTranslate","slideTo","activeIndex","maxTranslate","slides","lastMoveEvent","pop","velocityEvent","distance","velocity","Math","abs","momentumDuration","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","needsLoopFix","allowMomentumBounce","loop","centeredSlides","nextSlide","j","swipeDirection","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","transitionStart","animating","destroyed","setTimeout","transitionEnd","updateActiveIndex","updateSlidesClasses","longSwipesMs","Object","assign"],"sources":["/Users/crushedsummers/Desktop/Work/Application/portfolio22/node_modules/swiper/modules/free-mode/free-mode.js"],"sourcesContent":["import { elementTransitionEnd, now } from '../../shared/utils.js';\nexport default function freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd({\n    currentPos\n  }) {\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}